Django Docx Processor & LLM Analyzer Guide
This guide will help you create a Django app that:
 * Phase 1: Uploads a .docx, processes it, and converts it to JSON/Markdown.
 * Phase 2: Uploads that text file to Amazon Bedrock (Claude 3 Sonnet) via LangChain for analysis/summarization.
Prerequisites
 * Install Python Packages:
   You need Django, python-docx, AWS SDK (boto3), and LangChain for AWS.
   pip install django python-docx boto3 langchain-aws

 * AWS Credentials:
   Ensure your environment is configured with AWS credentials that have access to Bedrock. You can set these in your terminal or .env file:
   * AWS_ACCESS_KEY_ID
   * AWS_SECRET_ACCESS_KEY
   * AWS_DEFAULT_REGION (e.g., us-east-1)
 * Django Setup:
   django-admin startproject myproject
cd myproject
python manage.py startapp docx_reader

 * Settings: Add 'docx_reader' to INSTALLED_APPS in myproject/settings.py.
Phase 1: Docx Processing (Existing)
1. Forms (docx_reader/forms.py)
We add a second form here for the LLM upload step.
from django import forms

# --- Form for Phase 1: Docx Conversion ---
class DocxUploadForm(forms.Form):
    file = forms.FileField(
        label='Select a .docx file',
        help_text='Only .docx files are supported'
    )
    export_format = forms.ChoiceField(
        choices=[
            ('html', 'Preview in Browser'),
            ('json', 'Download as JSON'),
            ('markdown', 'Download as Markdown'),
        ],
        label='Output Format'
    )

    def clean_file(self):
        file = self.cleaned_data['file']
        if not file.name.endswith('.docx'):
            raise forms.ValidationError("Please upload a valid .docx file.")
        return file

# --- Form for Phase 2: LLM Analysis ---
class LLMSubmissionForm(forms.Form):
    document = forms.FileField(
        label='Upload Text/Markdown/JSON File',
        help_text='Upload the file generated in the previous step.'
    )
    user_prompt = forms.CharField(
        widget=forms.Textarea(attrs={'rows': 3}),
        label="Instructions for AI",
        initial="Summarize the following document and highlight key points.",
        required=True
    )

2. Views (docx_reader/views.py)
We add a new view llm_analysis to handle the Bedrock interaction.
import docx
import json
import boto3
from docx.text.paragraph import Paragraph
from docx.table import Table
from django.shortcuts import render, redirect
from django.http import HttpResponse
from .forms import DocxUploadForm, LLMSubmissionForm

# Import LangChain components
from langchain_aws import ChatBedrock
from langchain_core.messages import HumanMessage, SystemMessage

# --- Phase 1 View: Docx Processing ---
def process_docx(request):
    content_blocks = []
    
    if request.method == 'POST':
        form = DocxUploadForm(request.POST, request.FILES)
        if form.is_valid():
            docx_file = request.FILES['file']
            export_format = form.cleaned_data['export_format']
            
            try:
                doc = docx.Document(docx_file)
                
                # Iterate document body
                for element in doc.element.body:
                    if element.tag.endswith('p'):
                        para = Paragraph(element, doc)
                        text = para.text.strip()
                        if text:
                            style_name = para.style.name if para.style else ""
                            if style_name.startswith('Heading'):
                                try:
                                    level = int(style_name.split()[-1])
                                except ValueError:
                                    level = 2
                                content_blocks.append({'type': 'heading', 'content': text, 'level': level})
                            else:
                                content_blocks.append({'type': 'text', 'content': text})
                    elif element.tag.endswith('tbl'):
                        table = Table(element, doc)
                        table_data = []
                        for row in table.rows:
                            row_data = [cell.text.strip() for cell in row.cells]
                            table_data.append(row_data)
                        content_blocks.append({'type': 'table', 'content': table_data})

                # Export Logic
                if export_format == 'json':
                    json_data = json.dumps(content_blocks, indent=4)
                    response = HttpResponse(json_data, content_type='application/json')
                    response['Content-Disposition'] = 'attachment; filename="converted_doc.json"'
                    return response

                elif export_format == 'markdown':
                    md_lines = []
                    for block in content_blocks:
                        if block['type'] == 'heading':
                            prefix = '#' * min(block['level'], 6)
                            md_lines.append(f"{prefix} {block['content']}\n")
                        elif block['type'] == 'text':
                            md_lines.append(f"{block['content']}\n")
                        elif block['type'] == 'table':
                            rows = block['content']
                            if rows:
                                headers = rows[0]
                                md_lines.append("| " + " | ".join(headers) + " |")
                                md_lines.append("| " + " | ".join(['---'] * len(headers)) + " |")
                                for row in rows[1:]:
                                    md_lines.append("| " + " | ".join(row) + " |")
                            md_lines.append("\n")

                    response = HttpResponse("\n".join(md_lines), content_type='text/markdown')
                    response['Content-Disposition'] = 'attachment; filename="converted_doc.md"'
                    return response

            except Exception as e:
                form.add_error('file', f"Error processing file: {str(e)}")
    else:
        form = DocxUploadForm()

    return render(request, 'docx_reader/upload.html', {
        'form': form,
        'content_blocks': content_blocks
    })


# --- Phase 2 View: LLM Analysis ---
def llm_analysis(request):
    llm_response = ""
    error_message = ""

    if request.method == 'POST':
        form = LLMSubmissionForm(request.POST, request.FILES)
        if form.is_valid():
            uploaded_file = request.FILES['document']
            user_prompt = form.cleaned_data['user_prompt']

            try:
                # 1. Read file content (Assuming text/md/json)
                file_content = uploaded_file.read().decode('utf-8')

                # 2. Initialize LangChain Bedrock Chat
                # Ensure AWS credentials are set in environment variables
                chat = ChatBedrock(
                    model_id="anthropic.claude-3-sonnet-20240229-v1:0",
                    model_kwargs={"temperature": 0.5, "max_tokens": 4096}
                )

                # 3. Construct Messages
                messages = [
                    SystemMessage(content="You are a helpful assistant that analyzes documents."),
                    HumanMessage(content=f"{user_prompt}\n\nDocument Content:\n{file_content}")
                ]

                # 4. Invoke LLM
                response = chat.invoke(messages)
                llm_response = response.content

            except UnicodeDecodeError:
                error_message = "Could not read file. Please upload a valid Text, Markdown, or JSON file."
            except Exception as e:
                error_message = f"Error communicating with Bedrock: {str(e)}"
    else:
        form = LLMSubmissionForm()

    return render(request, 'docx_reader/llm_analysis.html', {
        'form': form,
        'llm_response': llm_response,
        'error_message': error_message
    })

3. App URLs (docx_reader/urls.py)
Add the path for the new LLM page.
from django.urls import path
from . import views

urlpatterns = [
    path('', views.process_docx, name='process_docx'),
    path('llm/', views.llm_analysis, name='llm_analysis'), # New URL
]

(Ensure myproject/urls.py includes this app's URLs as before)
4. Templates
A. Update Phase 1 Template (docx_reader/templates/docx_reader/upload.html)
Add a link to the LLM page at the top or bottom.
<!-- Add this button somewhere in your Phase 1 template -->
<div style="margin-bottom: 20px; padding: 10px; background: #e3f2fd; border: 1px solid #90caf9; border-radius: 4px;">
    <strong>Next Step:</strong> Want to analyze this document with AI? 
    <a href="{% url 'llm_analysis' %}" style="font-weight: bold; color: #1976d2;">Go to AI Analyzer &rarr;</a>
</div>

B. Create Phase 2 Template (docx_reader/templates/docx_reader/llm_analysis.html)
This template handles the file upload and uses JavaScript to handle the Markdown/Text download of the result.
<!DOCTYPE html>
<html>
<head>
    <title>AI Document Analysis</title>
    <style>
        body { font-family: sans-serif; max-width: 800px; margin: 2rem auto; padding: 0 1rem; }
        .container { border: 1px solid #ddd; padding: 2rem; border-radius: 8px; }
        .response-box { background: #f0f7ff; padding: 1.5rem; border: 1px solid #cce5ff; margin-top: 2rem; border-radius: 4px;}
        .error-box { background: #fff0f0; padding: 1rem; border: 1px solid #ffcccc; color: #d32f2f; margin-top: 1rem; }
        
        textarea { width: 100%; box-sizing: border-box; padding: 10px; margin-top: 5px;}
        button.primary { background: #6200ea; color: white; border: none; padding: 10px 20px; cursor: pointer; border-radius: 4px; font-size: 16px;}
        button.secondary { background: #fff; border: 1px solid #ccc; padding: 8px 16px; cursor: pointer; border-radius: 4px; margin-right: 5px;}
        button:hover { opacity: 0.9; }
        
        .actions { margin-top: 15px; padding-top: 15px; border-top: 1px solid #dae0e5; }
    </style>
</head>
<body>
    <div class="container">
        <div style="margin-bottom: 20px;">
            <a href="{% url 'process_docx' %}">&larr; Back to Docx Converter</a>
        </div>

        <h1>Analyze with Amazon Bedrock (Sonnet)</h1>
        
        <form method="post" enctype="multipart/form-data">
            {% csrf_token %}
            
            <div style="margin-bottom: 15px;">
                <strong>{{ form.document.label }}</strong>
                {{ form.document }}
                <div style="color: red;">{{ form.document.errors }}</div>
            </div>

            <div style="margin-bottom: 15px;">
                <strong>{{ form.user_prompt.label }}</strong>
                {{ form.user_prompt }}
            </div>

            <button type="submit" class="primary">Analyze Document</button>
        </form>

        {% if error_message %}
        <div class="error-box">
            <strong>Error:</strong> {{ error_message }}
        </div>
        {% endif %}

        {% if llm_response %}
        <div class="response-box">
            <h3 style="margin-top: 0;">AI Response:</h3>
            
            <!-- Display formatting preserved -->
            <div id="ai-content" style="white-space: pre-wrap;">{{ llm_response }}</div>
            
            <div class="actions">
                <strong>Download Response:</strong>
                <button type="button" class="secondary" onclick="downloadResponse('markdown')">As Markdown (.md)</button>
                <button type="button" class="secondary" onclick="downloadResponse('text')">As Text (.txt)</button>
            </div>
        </div>
        {% endif %}
    </div>

    <script>
        function downloadResponse(type) {
            const content = document.getElementById('ai-content').innerText;
            let filename = 'ai_analysis.txt';
            let mimeType = 'text/plain';

            if (type === 'markdown') {
                filename = 'ai_analysis.md';
                mimeType = 'text/markdown';
            }

            const blob = new Blob([content], { type: mimeType });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }
    </script>
</body>
</html>

Summary of Workflow
 * Step 1: User visits /, uploads report.docx, and downloads converted_doc.md.
 * Step 2: User clicks "Go to AI Analyzer".
 * Step 3: User uploads converted_doc.md to the new form, types "Summarize this", and clicks Submit.
 * Backend: Django reads the MD file, sends it to Amazon Bedrock via LangChain, and returns the summary.
 * Step 4: User sees the summary and clicks "As Markdown" to save the result locally.
