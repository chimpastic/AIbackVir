Django Docx Processor Guide
This guide will help you create a Django app that uploads a .docx file, processes it using the python-docx library, and displays the text, tables, and headings to the user.
Prerequisites
 * Install Django and python-docx:
   Run this in your terminal:
   pip install django python-docx

 * Create a Project (if you haven't already):
   django-admin startproject myproject
cd myproject
python manage.py startapp docx_reader

 * Register the App:
   Add 'docx_reader' to INSTALLED_APPS in myproject/settings.py.
The Code
1. Forms (docx_reader/forms.py)
We need a simple form to handle the file upload.
from django import forms

class DocxUploadForm(forms.Form):
    file = forms.FileField(
        label='Select a .docx file',
        help_text='Only .docx files are supported'
    )

    def clean_file(self):
        file = self.cleaned_data['file']
        if not file.name.endswith('.docx'):
            raise forms.ValidationError("Please upload a valid .docx file.")
        return file

2. Views (docx_reader/views.py)
To extract headings, tables, and text in order, we iterate through the document body. We check the style of every paragraph to see if it is a Heading.
import docx
from docx.text.paragraph import Paragraph
from docx.table import Table
from django.shortcuts import render
from .forms import DocxUploadForm

def process_docx(request):
    content_blocks = []
    
    if request.method == 'POST':
        form = DocxUploadForm(request.POST, request.FILES)
        if form.is_valid():
            docx_file = request.FILES['file']
            
            try:
                doc = docx.Document(docx_file)
                
                # Iterate over the document body elements in order
                for element in doc.element.body:
                    
                    # 1. Handle Paragraphs (Text & Headings)
                    if element.tag.endswith('p'):
                        para = Paragraph(element, doc)
                        text = para.text.strip()
                        
                        if text:
                            style_name = para.style.name if para.style else ""
                            
                            # Check if it's a Heading
                            if style_name.startswith('Heading'):
                                try:
                                    # Extract level from "Heading 1" -> 1
                                    level = int(style_name.split()[-1])
                                except ValueError:
                                    level = 2 # Default to h2 if parsing fails
                                
                                content_blocks.append({
                                    'type': 'heading', 
                                    'content': text, 
                                    'level': level
                                })
                            else:
                                # Standard Paragraph
                                content_blocks.append({
                                    'type': 'text', 
                                    'content': text
                                })
                            
                    # 2. Handle Tables
                    elif element.tag.endswith('tbl'):
                        table = Table(element, doc)
                        table_data = []
                        for row in table.rows:
                            row_data = [cell.text.strip() for cell in row.cells]
                            table_data.append(row_data)
                        content_blocks.append({'type': 'table', 'content': table_data})
                
            except Exception as e:
                form.add_error('file', f"Error processing file: {str(e)}")
    else:
        form = DocxUploadForm()

    return render(request, 'docx_reader/upload.html', {
        'form': form,
        'content_blocks': content_blocks
    })

3. App URLs (docx_reader/urls.py)
Create this file inside your app folder to map the view to a URL.
from django.urls import path
from . import views

urlpatterns = [
    path('', views.process_docx, name='process_docx'),
]

4. Main Project URLs (myproject/urls.py)
Tell the main project to look at your app's URLs.
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('docx_reader.urls')),
]

5. Template (docx_reader/templates/docx_reader/upload.html)
The template now handles three types: heading, text, and table. It uses the level variable to create dynamic heading tags (e.g., <h1...>, <h2...>).
<!DOCTYPE html>
<html>
<head>
    <title>Django Docx Reader</title>
    <style>
        body { font-family: sans-serif; max-width: 800px; margin: 2rem auto; padding: 0 1rem; }
        .container { border: 1px solid #ddd; padding: 2rem; border-radius: 8px; }
        .result-box { background: #f9f9f9; padding: 1rem; border: 1px solid #eee; margin-top: 2rem; }
        
        /* Typography */
        h1, h2, h3, h4, h5, h6 { color: #2c3e50; margin-top: 1.5rem; margin-bottom: 0.5rem; }
        p { line-height: 1.6; margin-bottom: 1rem; }
        
        /* Table Styling */
        table { width: 100%; border-collapse: collapse; margin: 1rem 0; background: white; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        
        /* Button Styling */
        button { background: #007bff; color: white; border: none; padding: 10px 20px; cursor: pointer; }
        button:hover { background: #0056b3; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Upload Docx File</h1>
        
        <form method="post" enctype="multipart/form-data">
            {% csrf_token %}
            {{ form.as_p }}
            <button type="submit">Extract Content</button>
        </form>

        {% if content_blocks %}
        <div class="result-box">
            <h3>Extracted Content:</h3>
            
            {% for block in content_blocks %}
                
                {% if block.type == 'heading' %}
                    <!-- Render dynamic heading tag (e.g., <h1>, <h2>) -->
                    <h{{ block.level }}>{{ block.content }}</h{{ block.level }}>

                {% elif block.type == 'text' %}
                    <p>{{ block.content }}</p>
                
                {% elif block.type == 'table' %}
                    <table>
                        <tbody>
                        {% for row in block.content %}
                            <tr>
                                {% for cell in row %}
                                    <td>{{ cell }}</td>
                                {% endfor %}
                            </tr>
                        {% endfor %}
                        </tbody>
                    </table>
                {% endif %}

            {% endfor %}
        </div>
        {% endif %}
    </div>
</body>
</html>

Summary
 * Heading Detection: We examine para.style.name. If it starts with "Heading", we parse the number at the end (e.g., "Heading 1" becomes level 1).
 * Dynamic Template Tags: In HTML, <h{{ block.level }}> allows us to render the exact heading level that was used in the Word document.
 * Sequence Preserved: Because we still loop through doc.element.body, headings appear exactly where they should relative to the text and tables.
